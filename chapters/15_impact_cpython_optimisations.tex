\chapter{Impact of CPython performance enhancements on xDSL pattern rewriting}
\label{chap:impact-cpython-pattern-rewriting}



\section{Faster CPython}
\label{sec:faster-cpython}

% Hook
\acf{pep} 659 asserts that ``Python widely acknowledged as slow'' \cite{pep659}.
% Argument
This comes partially as an inherent trade-off from the benefits of its interpreted runtime and expressive dynamic semantics, meaning it cannot achieve the general-purpose performance of ahead-of-time compiled languages such as C++ or FORTRAN. However, it is feasible for Python implementations to be competitive with fast implementations of other scripting languages with similar trade-offs, such as Javascript's V8 or Lua's LuaJIT. The Faster CPython project is an attempt to achieve this goal in Python's reference implementation. Over the course of the recent CPython major versions, new optimisations have been gradually added as part of this project, resulting in incremental performance gains (\autoref{tab:faster-cpython}).
% Link
This section discusses the details of these optimisations, and their effect on CPython's performance. % TODO: Change link to be in context of how we extend stuff...


\begin{table}[H]
  \caption{Incremental improvements of the geometric mean of speedups across the PyPerformance benchmark suite (full results \autoref{chap:pyperformance-version-comparison}), achieved by optimisations to the CPython interpreter.}
  \label{tab:faster-cpython}
  % TODO: The rows/columns in this table should probably be rethought -- N/A is not a good thing to have!
  \centering
  \begin{tabular}{lll}
    \toprule
    \textbf{Python version} & \textbf{Optimisation over previous} & \textbf{PyPerformance speedup} \\
    \midrule
    CPython 3.10.17 & N/A & N/A \\
    CPython 3.11.12 & Specialising adaptive interpreter & $1.26$ \\
    % CPython 3.12.10 & Comprehension inlining & $x$ \\
    CPython 3.13.3 & Version bump & $1.17$ \\
    CPython 3.13.3 & Enabled experimental JIT & $1.05$ \\
    CPython 3.14.0a7 & Version bump & $x$ \\
    CPython 3.14.0a7 & Enabled tail call interpreter & $x$ \\
    % \midrule
    % PyPy 3.11.11 & JIT compilation & $x$ \\
    \bottomrule
  \end{tabular}
\end{table}

\subsection{Specialising adaptive interpreter}
\label{ssec:specialising-adaptive-interpreter}


%% How is it implemented?
% Hook
The specialising adaptive interpreter is an implementation of \ac{jit} adaptive optimisation (introduced in \autoref{ssec:adaptive-optimisation}) which was added to CPython version 3.11 in 2022.
% Argument
% Link

%% How does it perform?
% Hook
% Argument
% Link


\subsection{Experimental JIT compiler}
\label{ssec:experimental-jit-compiler}

%% Motivation
% Hook
CPython's experimental \ac{jit} compiler is an implementation of the copy-and-patch machine code generation approach (introduced in \autoref{sssec:copy-and-patch-compilation}), which was added to CPython in 3.13 in 2024.
% Argument
% What did Python do?
% Changes to facilitate this
% Actual changes
% Link

%% How does it perform?
% Hook
% Argument
% Link

\subsection{Tail call interpreter}
\label{ssec:tail-call-interpreter}

%% Motivation
% Hook
In addition to \ac{jit} optimisations leveraging runtime information, there are also other opportunities for improving the implementation of interpreted runtimes.
% Argument
Interpreters can be modelled as a loop which iterates through a sequence of bytecode instructions, with a switch statement selecting the evaluation logic at each iteration for the current instruction.
% Link

%% How does it work?
% Hook
% Argument
% Link

%% How does it perform?
% Hook
% Argument
% Link


\section{Specialising adaptive interpreter}
\section{JIT compilation}
\section{Tail call interpreter}


% \chapter{Ideally final optimisation stuff}
