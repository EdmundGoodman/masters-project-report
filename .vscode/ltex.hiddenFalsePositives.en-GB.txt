{"rule":"UPPERCASE_SENTENCE_START","sentence":"^\\Qlineprofiler provides this functionality to a line level \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, but this is still one level of abstraction over the increasingly complex implementation of CPython's interpreter.\\E$"}
{"rule":"THREE_NN","sentence":"^\\QOur work leverages these tools to make accurate measurements of compiler framework performance.\\E$"}
{"rule":"WANT","sentence":"^\\QThis existing body of work The standard library includes the timeit utility, which measures the wall clock time to execute code snippets.\\E$"}
{"rule":"THREE_NN","sentence":"^\\QOther tools provide more specialised functionality, for example Airspeed Velocity \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q visualising performance regressions across repository commits, and pyperformance \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q benchmarking the performance of the Python language implementation itself across a variety of workloads.\\E$"}
{"rule":"MORFOLOGIK_RULE_EN_GB","sentence":"^\\QFor \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q, we invoke [breaklines, breakafter=-]text mlir-opt constant_folding.mlir –canonicalize –mlir-timing.\\E$"}
{"rule":"THREE_NN","sentence":"^\\QThis process only relies on parsing and printing logic for debugging, as its main code generation flow operates entirely on binary representations.\\E$"}
{"rule":"PASSIVE_VOICE","sentence":"^\\QThe term was coined by Saavedra et al. in their 1995 paper \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q “Performance Characterization of Optimizing Compilers”.\\E$"}
{"rule":"THREE_NN","sentence":"^\\QSimilarly to operation instantiation, there are three ways operations in a block can be traversed: directly iterating over the internal operation array pairedOneLightBlue 1; directly iterating over the iterable provided by the block pairedTwoDarkBlue 2; and using the recursive walk helper method pairedThreeLightGreen 3 (Listing \\E(?:Dummy|Ina|Jimmy-)[0-9]+\\Q).\\E$"}
{"rule":"THREE_NN","sentence":"^\\QPython performance measurement and optimisation.\\E$"}
